---
title: "The Complete Guide to MDX Components: A Showcase of All Elements"
excerpt: "A comprehensive demonstration of all MDX components available in our blog, including code blocks with syntax highlighting, embedded videos, tweets, callouts, and interactive elements."
publishedAt: "2024-12-12"
author: "engineering-team"
category: "production-systems"
tags:
  - mdx
  - documentation
  - components
  - showcase
featured: true
readTime: 15
---

This post demonstrates all the MDX components available for creating rich, interactive blog content. Use this as a reference when writing new posts.

## Typography and Basic Formatting

### Headings

Headings from H2 to H4 are supported. H1 is reserved for the post title. Each heading automatically gets an anchor link for easy sharing.

### Text Formatting

You can use **bold text** for emphasis, _italic text_ for subtle emphasis, and ~~strikethrough~~ for deleted content. You can also combine them: **_bold and italic_**.

Here's a paragraph with some `inline code` to demonstrate how code snippets appear within regular text. This is useful for mentioning function names like `useEffect()` or variable names like `apiEndpoint`.

### Links

Links can be [internal](/blog) or [external](https://github.com) (external links open in a new tab automatically). Here's a link to our [AI Security services](/services/ai-security).

### Blockquotes

> "The best way to predict the future is to invent it." â€” Alan Kay
>
> This is a multi-paragraph blockquote. It's perfect for highlighting important quotes or key takeaways from your content.

## Lists

### Unordered Lists

Here are the key principles of production AI systems:

- **Reliability First**: Systems must handle failures gracefully
- **Observability**: You can't fix what you can't measure
- **Security by Design**: Security considerations from day one
- **Scalability**: Architecture that grows with your needs
  - Horizontal scaling for compute
  - Distributed caching
  - Load balancing strategies

### Ordered Lists

Follow these steps to deploy your AI model:

1. Prepare your model artifacts and dependencies
2. Create a containerized environment
3. Set up your inference endpoint
4. Configure auto-scaling policies
5. Deploy to staging and run integration tests
6. Promote to production with canary deployment

### Task Lists

Project checklist for AI deployment:

- [x] Model training completed
- [x] Evaluation metrics validated
- [x] Security review passed
- [ ] Load testing in progress
- [ ] Documentation pending

## Code Blocks

### Basic Syntax Highlighting

Here's a TypeScript example with automatic syntax highlighting:

```typescript
interface User {
  id: string;
  name: string;
  email: string;
  role: "admin" | "user";
}

async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  if (!response.ok) {
    throw new Error(`Failed to fetch user: ${response.statusText}`);
  }
  return response.json();
}
```

### Python Example

```python
import openai
from typing import List, Dict

def generate_embeddings(texts: List[str]) -> List[List[float]]:
    """Generate embeddings for a list of texts using OpenAI."""
    response = openai.embeddings.create(
        model="text-embedding-3-small",
        input=texts
    )
    return [item.embedding for item in response.data]

# Usage example
documents = ["Hello world", "AI is transforming industries"]
embeddings = generate_embeddings(documents)
```

### Bash Commands

```bash
# Install dependencies
npm install @anthropic-ai/sdk

# Set up environment variables
export ANTHROPIC_API_KEY="your-api-key"

# Run the application
npm run dev
```

### JSON Configuration

```json
{
  "model": "claude-3-opus",
  "max_tokens": 4096,
  "temperature": 0.7,
  "system": "You are a helpful AI assistant.",
  "messages": [
    {
      "role": "user",
      "content": "Explain quantum computing in simple terms."
    }
  ]
}
```

### Line Highlighting

You can highlight specific lines to draw attention to important code:

```typescript {3-5}
function processRequest(request: Request) {
  // Validate the request
  if (!request.body) {
    throw new ValidationError("Request body is required");
  }

  // Process the validated request
  return handleRequest(request);
}
```

## Callouts

Use callouts to highlight important information:

<Callout type="info" title="Good to Know">
  Callouts are perfect for providing additional context or helpful tips that
  don't fit in the main flow of content.
</Callout>

<Callout type="warning" title="Be Careful">
  This approach may have performance implications at scale. Consider caching
  strategies for high-traffic applications.
</Callout>

<Callout type="error" title="Common Mistake">
  Never store API keys in your frontend code or commit them to version control.
  Use environment variables instead.
</Callout>

<Callout type="success" title="Best Practice">
  Always implement rate limiting and input validation when exposing AI endpoints
  to protect against abuse.
</Callout>

<Callout type="tip">
  Pro tip: Use streaming responses for better user experience when generating
  long-form content with LLMs.
</Callout>

<Callout type="note">
  This feature requires Node.js 18 or later and is not compatible with older
  versions.
</Callout>

## Tables

Tables are great for comparing options or presenting structured data:

| Feature         | GPT-4     | Claude 3 Opus | Gemini Pro |
| --------------- | --------- | ------------- | ---------- |
| Context Window  | 128K      | 200K          | 1M         |
| Vision          | Yes       | Yes           | Yes        |
| Code Generation | Excellent | Excellent     | Good       |
| Reasoning       | Strong    | Strong        | Good       |
| API Pricing     | $$$       | $$$           | $$         |

## Media Embeds

### YouTube Videos

Embed YouTube videos with an optional caption:

<YouTube
  id="dQw4w9WgXcQ"
  title="Introduction to AI Engineering"
  caption="A comprehensive overview of modern AI engineering practices"
/>

### Twitter/X Embeds

Embed tweets to reference discussions or announcements:

<Tweet id="1734704232839241828" />

## Interactive Components

### Step-by-Step Guides

<Steps>
  <Step title="Set Up Your Environment">
    Install the required dependencies and configure your API keys. Make sure you
    have Node.js 18+ installed.
  </Step>
  <Step title="Create Your First Agent">
    Define your agent's capabilities, tools, and system prompt. Start with a
    simple task and iterate.
  </Step>
  <Step title="Add Error Handling">
    Implement robust error handling and retry logic. AI systems can fail in
    unexpected ways.
  </Step>
  <Step title="Deploy and Monitor">
    Deploy your agent to production and set up comprehensive monitoring and
    alerting.
  </Step>
</Steps>

### Tabbed Content

<Tabs defaultValue="npm">
  <Tab value="npm" label="npm">
    ```bash npm install @anthropic-ai/sdk ```
  </Tab>
  <Tab value="yarn" label="yarn">
    ```bash yarn add @anthropic-ai/sdk ```
  </Tab>
  <Tab value="pnpm" label="pnpm">
    ```bash pnpm add @anthropic-ai/sdk ```
  </Tab>
</Tabs>

### Accordion / FAQ

<Accordion>
  <AccordionItem
    title="What is the difference between RAG and fine-tuning?"
    defaultOpen
  >
    RAG (Retrieval-Augmented Generation) retrieves relevant context at query
    time, while fine-tuning permanently adjusts model weights. RAG is better for
    frequently changing data; fine-tuning is better for consistent behavioral
    changes.
  </AccordionItem>
  <AccordionItem title="How do I handle rate limits?">
    Implement exponential backoff with jitter, use request queuing, and consider
    caching responses for repeated queries. Most APIs provide rate limit headers
    you can use to proactively throttle.
  </AccordionItem>
  <AccordionItem title="What's the best way to evaluate LLM outputs?">
    Combine automated metrics (BLEU, ROUGE, perplexity) with human evaluation.
    For production systems, implement A/B testing and collect user feedback
    systematically.
  </AccordionItem>
</Accordion>

## File Structure Visualization

<FileTree>
  {`
src/
  components/
    ui/
      Button.tsx*
      Input.tsx
    blog/
      BlogPost.tsx*
      BlogCard.tsx
  lib/
    api.ts
    utils.ts*
  app/
    page.tsx
    layout.tsx
`}
</FileTree>

## Comparison Blocks

<Comparison
  left={{ title: "Don't Do This", type: "bad" }}
  right={{ title: "Do This Instead", type: "good" }}
>
  <ComparisonSide side="left">
    ```typescript // Storing API key in code const apiKey = "sk-abc123..."; ```
  </ComparisonSide>
  <ComparisonSide side="right">
    ```typescript // Using environment variable const apiKey =
    process.env.API_KEY; ```
  </ComparisonSide>
</Comparison>

## Link Previews

<LinkPreview
  url="https://github.com/anthropics/anthropic-sdk-python"
  title="anthropic-sdk-python"
  description="Official Python SDK for the Anthropic API, providing easy access to Claude and other Anthropic models."
  siteName="GitHub"
  image="https://opengraph.githubassets.com/1/anthropics/anthropic-sdk-python"
/>

## Images with Captions

<ImageWithCaption
  src="https://images.unsplash.com/photo-1677442136019-21780ecad995?w=1200"
  alt="AI neural network visualization showing interconnected nodes and data flow"
  caption="Modern AI systems rely on complex neural architectures to process and generate content"
  rounded
  border
/>

## Horizontal Rules

Use horizontal rules to separate major sections:

---

## GitHub Flavored Markdown Features

### Autolinked References

GitHub-style references are automatically linked:

- Issue references: #123
- URLs are auto-linked: https://procedure.tech

### Footnotes

Here's a sentence with a footnote[^1] and another one[^2].

[^1]: This is the first footnote with additional context.

[^2]: And here's another footnote explaining something else.

## Conclusion

This showcase demonstrates all the MDX components available for creating rich blog content. Use these components thoughtfully to enhance readability and engagement without overwhelming your readers.

Key takeaways:

1. **Code blocks** with syntax highlighting make technical content accessible
2. **Callouts** draw attention to important information
3. **Interactive components** like tabs and accordions organize complex content
4. **Media embeds** bring external content inline
5. **Comparisons** help readers understand trade-offs

For questions about these components or to suggest new ones, reach out to the engineering team.
